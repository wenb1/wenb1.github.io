---
layout: post
title: 归并排序(Merge Sort)
categories: Algorithm
description: 讲解归并排序
keywords: Algorithm，算法，归并排序
---

归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。

![归并排序1](/images/posts/algorithms/merge_sort_1.jpg)

动态示意图如下：

![归并排序1](/images/posts/algorithms/merge_sort_2.gif)

归并排序使用的就是分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。从刚才的描述，你有没有感觉到，分治思想跟我们前面讲的递归思想很像。是的，分治算法一般都是用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧，这两者并不冲突。

现在看看如何用递归代码来实现归并排序。

首先，写递归代码的技巧就是，分析得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码。所以，要想写出归并排序的代码，我们先写出归并排序的递推公式。

```markdown
递推公式：
merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))

终止条件：
p >= r 不用再继续分解
```

merge_sort(p…r) 表示，给下标从 p 到 r 之间的数组排序。我们将这个排序问题转化为了两个子问题，merge_sort(p…q) 和 merge_sort(q+1…r)，其中下标 q 等于 p 和 r 的中间位置，也就是 (p+r)/2。当下标从 p 到 q 和从 q+1 到 r 这两个子数组都排好序之后，我们再将两个有序的子数组合并在一起，这样下标从 p 到 r 之间的数据就也排好序了。

实现如下：

```java
public class MergeSort {
    public static void mergeSort(int[] array){
        sort(array, 0, array.length-1);
    }

    private static void sort(int[] array, int lo, int hi){

        if(lo>=hi)
            return;

        int mid=(lo+hi)/2;
        sort(array, lo, mid);
        sort(array, mid+1, hi);
        merge(array, lo, mid, hi);
    }

    private static void merge(int[] array, int lo, int mid, int hi){
        int[] aux=new int[array.length];
        int i=lo, j=mid+1;

        for(int k=lo;k<=hi;k++){
            aux[k]=array[k];
        }

        for(int k=lo;k<=hi;k++){
            if(i>mid)
                array[k]=aux[j++];
            else if(j>hi)
                array[k]=aux[i++];
            else if(aux[j]<aux[i])
                array[k]=aux[j++];
            else
                array[k]=aux[i++];
        }
    }
}

```

`merge()`这个函数的作用就是，将已经有序的A[p…q]和A[q+1…r]合并成一个有序的数组，并且放入 A[p…r]。

**第一，归并排序是稳定的排序算法吗？**

归并排序稳不稳定关键要看`merge()`函数，也就是两个有序子数组合并成一个有序数组的那部分代码。在合并的过程中，如果A[p…q]和A[q+1…r]之间有值相同的元素，那我们可以像伪代码中那样，先把A[p…q]中的元素放入aux数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个**稳定的排序算法**。

**第二，归并排序的时间复杂度是多少？**

归并排序涉及递归，时间复杂度的分析稍微有点复杂。递归的适用场景是，一个问题 a 可以分解为多个子问题 b、c，那求解问题a就可以分解为求解问题 b、c。问题b、c解决之后，我们再把 b、c的结果合并成 a 的结果。

如果我们定义求解问题 a 的时间是T(a)，求解问题b、c的时间分别是T(b) 和T( c)，那我们就可以得到这样的递推关系式：

```markdown
T(a) = T(b) + T(c) + K
```

其中 K 等于将两个子问题 b、c 的结果合并成问题 a 的结果所消耗的时间。

从刚刚的分析，我们可以得到一个重要的结论：不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。

我们假设对n个元素进行归并排序需要的时间是T(n)，那分解成两个子数组排序的时间都是T(n/2)。我们知道，`merge()`函数合并两个有序子数组的时间复杂度是O(n)。所以，套用前面的公式，归并排序的时间复杂度的计算公式就是：

```markdown
(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。
T(n) = 2*T(n/2) + n； n>1
```

我们再进一步分解一下计算过程。

```
T(n) = 2*T(n/2) + n 
     = 2*(2*T(n/4) + n/2) + n  = 4*T(n/4) + 2*n 
     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n 
     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
     ...... 
     = 2^k * T(n/2^k) + k * n 
     ......
```

通过这样一步一步分解推导，我们可以得到T(n) = 2^kT(n/2^k)+kn。当T(n/2^k)=T(1)时，也就是n/2^k=1，我们得到 k=log2n。我们将k值代入上面的公式，得到T(n)=Cn+nlog2n。如果我们用大O标记法来表示的话，T(n)就等于 O(nlogn)。所以归并排序的时间复杂度是O(nlogn)。

从我们的原理分析和伪代码可以看出，归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是**最好情况**、**最坏情况**，还是**平均情况**，**时间复杂度都是 O(nlogn)**。

**第三，归并排序的空间复杂度是多少？**

归并排序的时间复杂度任何情况下都是O(nlogn)，看起来非常优秀。（待会儿你会发现，即便是快速排序，最坏情况下，时间复杂度也是 O(n^2)。）但是，归并排序并没有像快排那样，应用广泛，这是为什么呢？因为它有一个致命的“弱点”，那就是归并排序不是原地排序算法。这是因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。

在任意时刻，CPU只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过n个数据的大小，所以**空间复杂度是 O(n)**。