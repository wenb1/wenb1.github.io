---
layout: post
title: Java之反射(Reflection)
categories: Java
description: 讲解Java中的反射
keywords: Java, reflection, 反射
---

Java反射机制(Reflection)是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。

# 1. 反射基本介绍

简单来说，反射就是把Java类中的各个组成部分，比如成员变量，构造方法，方法等信息，映射成Java对象，有了这些对象后就可以做其它事。

一般来说反射是用来做框架的，或者说可以做一些抽象度比较高的底层代码。在日常的第三方应用开发过程中，经常会遇到某个类的某个成员变量、方法或是属性是私有的或是只对系统应用开放，这时候就可以利用Java的反射机制通过反射来获取所需的私有成员或是方法。当然，也不是所有的都适合反射，之前就遇到一个案例，通过反射得到的结果与预期不符。阅读源码发现，经过层层调用后在最终返回结果的地方对应用的权限进行了校验，对于没有权限的应用返回值是没有意义的缺省值，否则返回实际值起到保护用户的隐私目的。

# 2. 反射的原理

我们在平时写代码的时候，创建的类(`class`)文件都以`.java`为后缀名存储的，之后它会被编译为以`.class`为后缀的文件，最后被执行的其实是`.class`文件。

除了基本数据类型以外，Java的其它类型全部都是`class`(包括`interface`)，这也是为什么说在Java中，万物皆对象，例如`String`，`Object`，`Runnable`等，我们可以说，`class`(包括`interface`)的本质就是数据类型。

而`class`是由JVM在执行过程中动态加载的。JVM在第一次读取到一种`class`类型时，将其加载进内存。加载一种`class`，JVM就为其创建一个`Class`类型的实例，并关联起来。

注意：这里的`Class`类型是一个名叫`Class`的`class`。它长这样：

```
public final class Class {
    private Class() {}
}
```

以`String`类为例，当JVM加载`String`类时，它首先通过类加载器加载`String.class`文件到内存，然后，为`String`类创建一个`Class`实例并关联起来：

```
Class clazz = new Class(String);
```

这个`Class`实例是JVM内部创建的，如果我们查看JDK源码，可以发现`Class`类的构造方法是`private`，只有JVM能创建`Class`实例，Java程序是无法创建`Class`实例的。

由于JVM为每个加载的`class`创建了对应的`Class`实例，并在实例中保存了该`class`的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个`Class`实例，我们就可以通过这个`Class`实例获取到该实例对应的`class`的所有信息。

这种通过`Class`实例获取`class`信息的方法称为反射。

# 3. 反射的使用