---
layout: post
title: 图(Graph)
categories: DataStructure
description: 讲解图
keywords: DataStructure，图，Graph
---

微博、微信、LinkedIn 这些社交软件我想你肯定都玩过吧。在微博中，两个人可以互相关注；在微信中，两个人可以互加好友。那你知道，如何存储微博、微信等这些社交网络的好友关系吗？

# 1. 什么是图？

图是一种非线性表数据结构，和树比起来，这是一种更加复杂的非线性表结构。

图中的元素我们叫做**顶点（vertex）**。从下图中可以看出来，图中的一个顶点可以与任意其他顶点建立连接关系。这种连接关系叫做**边（edge）**。

![graph_1](/images/posts/datastructure/graph_1.jpg)

我们生活中就有很多符合图这种结构的例子。比如，开头讲到的社交网络，就是一个非常典型的图结构。

拿微信举个例子。我们可以把用户看成一个顶点，如果有两个用户互加好友，那么就在两者之间建立一条边。所以，整个微信的好友关系就可以用一张图来表示。其中，每个用户有多少个好友，对应到图中，就叫做顶点的度（degree），就是跟顶点相连接的边的条数。

实际上，微博的社交关系跟微信还有点不一样，或者说更加复杂一点。微博允许单向关注，也就是说，用户 A 关注了用户 B，但用户 B 可以不关注用户 A。那我们如何用图来表示这种单向的社交关系呢？

我们可以引入边的“方向”的概念。

如果用户 A 关注了用户 B，我们就在图中画一条从 A 到 B 的带箭头的边，来表示边的方向。如果用户 A 和用户 B 互相关注了，那我们就画一条从 A 指向 B 的边，再画一条从 B 指向 A 的边。我们把这种边有方向的图叫做**“有向图”**。以此类推，我们把边没有方向的图就叫做**“无向图”**。

![graph_2](/images/posts/datastructure/graph_2.jpg)

我们刚刚讲过，无向图中有“度”这个概念，表示一个顶点有多少条边。在有向图中，我们把度分为入度（In-degree）和出度（Out-degree）。

顶点的入度，表示有多少条边指向这个顶点；顶点的出度，表示有多少条边是以这个顶点为起点指向其他顶点。对应到微博的例子，入度就表示有多少粉丝，出度就表示关注了多少人。

前面讲到了微信、微博、无向图、有向图，现在我们再来看另一种社交软件：QQ。

QQ中的社交关系稍微复杂一点。因为QQ中有亲密度这一机制，就是如果两个人之间互发的消息越多，那么亲密度越高，反之，则亲密度较低。如果我们要记录这种关系，就需要把图更进化一些，就是**带权图（weighted graph）**。在带权图中，每条边都有一个权重（weight），我们可以通过这个权重来表示 QQ 好友间的亲密度。

![graph_3](/images/posts/datastructure/graph_3.jpg)

# 2. 如何存储图？

## 2.1 邻接矩阵存储方法

图最直观的一种存储方法就是，**邻接矩阵（Adjacency Matrix）**。

邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点 i 与顶点 j 之间有边，我们就将 A[i][j]和 A[j][i]标记为 1；对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 A[i][j]标记为 1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 A[j][i]标记为 1。对于带权图，数组中就存储相应的权重。

![graph_4](/images/posts/datastructure/graph_4.jpg)

用邻接矩阵来表示一个图，虽然简单、直观，但是比较浪费存储空间。

对于无向图来说，如果 A[i][j]等于 1，那 A[j][i]也肯定等于 1。实际上，我们只需要存储一个就可以了。也就是说，无向图的二维数组中，如果我们将其用对角线划分为上下两部分，那我们只需要利用上面或者下面这样一半的空间就足够了，另外一半白白浪费掉了。

## 2.2 邻接表存储方法

针对上面邻接矩阵比较浪费内存空间的问题，我们来看另外一种图的存储方法，**邻接表（Adjacency List）**。

如图。乍一看，邻接表是不是有点像散列表？每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。另外我需要说明一下，图中的是一个有向图的邻接表存储方式，每个顶点对应的链表里面，存储的是指向的顶点。对于无向图来说，也是类似的，不过，每个顶点的链表中存储的，是跟这个顶点有边相连的顶点。

![graph_5](/images/posts/datastructure/graph_5.jpg)

这也体现了我们常说的，时间换空间，空间换时间的设计思想。邻接矩阵存储起来比较浪费空间，但是使用起来比较节省时间。相反，邻接表存储起来比较节省空间，但是使用起来就比较耗时间。